<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Triadic Inspiration</title>
    <style>
        body, html { 
            margin: 0; padding: 0; 
            width: 100%; height: 100%; 
            background: #000; 
            overflow: hidden; 
            display: flex; align-items: center; justify-content: center; 
            cursor: pointer; /* Feedback that the screen is clickable */
        }
        canvas { 
            width: 100vw; height: 100vh; 
            object-fit: contain; 
            image-rendering: pixelated; 
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const COLS = 160, ROWS = 90;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = COLS; canvas.height = ROWS;

const PALETTE_LIBRARY = [
    ["#FF8C42", "#FF3C38", "#052F5F"], ["#E3B448", "#3A6351", "#A7333F"],
    ["#4B0082", "#ADFF2F", "#00CED1"], ["#1B3022", "#ECAC32", "#392F5A"],
    ["#E68A3F", "#4FA36F", "#6A4FA3"], ["#9B59B6", "#1ABC9C", "#F1C40F"],
    ["#FF6B6B", "#4ECDC4", "#1A535C"], ["#2C3E50", "#E74C3C", "#27AE60"],
    ["#2D5A27", "#F39C12", "#C0392B"], ["#FF00FF", "#00FFFF", "#FFFF00"]
];

let seeds = [];
let currentPalette = [];
let targetPalette = [];
let lerpFactor = 0;
let isPaused = false;
let holdTimer = 0;
const HOLD_DURATION = 266; 

// Timing variables for FPS independence
let lastTime = 0;
const TARGET_FPS = 60;

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return {r, g, b};
}

function init() {
    const p = PALETTE_LIBRARY[Math.floor(Math.random() * PALETTE_LIBRARY.length)];
    currentPalette = p.map(hexToRgb);
    targetPalette = [...currentPalette];
    
    for (let i = 0; i < 80; i++) {
        let type = 0;
        const r = Math.random();
        if (r > 0.6 && r <= 0.9) type = 1;
        else if (r > 0.9) type = 2;
        
        seeds.push({
            x: Math.random() * COLS,
            y: Math.random() * ROWS,
            vx: (Math.random() - 0.5) * 0.12,
            vy: (Math.random() - 0.5) * 0.12,
            type: type,
            strength: 0.7 + Math.random() * 0.6
        });
    }
    requestAnimationFrame(animate);
}

function updateColors(deltaTimeMultiplier) {
    if (lerpFactor < 1) {
        // Multiplied by delta to keep transition speed consistent
        lerpFactor += 0.01 * deltaTimeMultiplier; 
    } else if (!isPaused) {
        holdTimer += deltaTimeMultiplier;
        if (holdTimer > HOLD_DURATION) {
            holdTimer = 0;
            lerpFactor = 0;
            currentPalette = [...targetPalette];
            const next = PALETTE_LIBRARY[Math.floor(Math.random() * PALETTE_LIBRARY.length)];
            targetPalette = next.map(hexToRgb);
        }
    }
}

function animate(currentTime) {
    // Calculate Delta Time
    if (!lastTime) lastTime = currentTime;
    const elapsed = currentTime - lastTime;
    lastTime = currentTime;

    // This multiplier is 1.0 at 60fps. At 120fps, it's 0.5.
    const dtMultiplier = elapsed / (1000 / TARGET_FPS);

    updateColors(dtMultiplier);
    
    if (!isPaused) {
        for (let s of seeds) {
            // Movement speed is now independent of refresh rate
            s.x += s.vx * dtMultiplier; 
            s.y += s.vy * dtMultiplier;
            
            if (s.x < 0 || s.x > COLS) s.vx *= -1;
            if (s.y < 0 || s.y > ROWS) s.vy *= -1;
        }
    }

    const imgData = ctx.createImageData(COLS, ROWS);
    const activeColors = [0, 1, 2].map(t => ({
        r: currentPalette[t].r + (targetPalette[t].r - currentPalette[t].r) * Math.min(lerpFactor, 1),
        g: currentPalette[t].g + (targetPalette[t].g - currentPalette[t].g) * Math.min(lerpFactor, 1),
        b: currentPalette[t].b + (targetPalette[t].b - currentPalette[t].b) * Math.min(lerpFactor, 1)
    }));

    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            let minDist = Infinity;
            let closestType = 0;
            for (const s of seeds) {
                const dist = ((x - s.x) ** 2 + (y - s.y) ** 2) * s.strength;
                if (dist < minDist) { minDist = dist; closestType = s.type; }
            }
            const idx = (y * COLS + x) * 4;
            const color = activeColors[closestType];
            imgData.data[idx] = color.r;
            imgData.data[idx+1] = color.g;
            imgData.data[idx+2] = color.b;
            imgData.data[idx+3] = 255;
        }
    }
    ctx.putImageData(imgData, 0, 0);
    requestAnimationFrame(animate);
}

// Fullscreen Toggle on Click/Touch
window.addEventListener("click", () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
});

window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
        isPaused = !isPaused; 
    } else if (e.code === "Enter" || e.code === "NumpadEnter") {
        // Save functionality remains here
        const offscreen = document.createElement('canvas');
        offscreen.width = 1920; offscreen.height = 1080;
        const oCtx = offscreen.getContext('2d');
        oCtx.imageSmoothingEnabled = false;
        oCtx.drawImage(canvas, 0, 0, 1920, 1080);
        const link = document.createElement('a');
        link.download = `triadic-${Date.now()}.png`;
        link.href = offscreen.toDataURL("image/png");
        link.click();
    }
});

init();
</script>
</body>
</html>